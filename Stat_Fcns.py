import pandas as pd
import numpy as np
import datetime as dt
import time as time
import os

import arch.unitroot as UnitRoot
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import acf,pacf, adfuller
from operator import itemgetter
from sklearn import linear_model as LM
from sklearn.decomposition import PCA
from scipy.stats import anderson
from nolds import hurst_rs

def adTest(data):
    #@FORMAT: data = np(values)
    stat, critical_val, sig_level = anderson(data)
    return stat, critical_val, sig_level

#Calcs p values and correlations for all lags
def acf_fcn(data,lags=2,alpha=.05):
    #@FORMAT: data = np(values)
    try:
        acfvalues, confint,qstat,pvalues = acf(data,nlags=lags,qstat=True,alpha=alpha)
        return [acfvalues,pvalues]
    except:
        return [np.nan]




#Calcs only correlations for all lags
def acf_fcn_only_cor(data,lags=2,alpha=.05):
    #@FORMAT: data = np(values)
    result = acf_fcn(data,lags, alpha)
    return result[0]





#Calcs the p value for for the best fit lag
def acf_fcn_highestlag(data,lags,alpha=.05):
    #@FORMAT: data = np(values)
    acfarr = acf_fcn(data,lags,alpha=alpha)
    lagNum = range(1,acfarr[1].shape[0]+1)
    lagP = np.array(acfarr[1])
    ordered_arr = np.column_stack((lagNum,lagP))
    #print('unordered',ordered_arr)
    ordered_arr.sort(axis=-1)
    return ordered_arr[0]

#Calcs the p value for for the best fit lag, include only P Value
def acf_fcn_highestlag_P_Val(data,lags,alpha=.05):
    #@FORMAT: data = np(values)
    acfarr = acf_fcn(data,lags,alpha=alpha)
    lagNum = range(1,acfarr[1].shape[0]+1)
    lagP = np.array(acfarr[1])
    ordered_arr = np.column_stack((lagNum,lagP))
    ordered_arr.sort(axis=-1)
    ordered_arr = pd.DataFrame(ordered_arr[0]).iloc[:,0].values.tolist()
    return ordered_arr[0]



#Calcs p value for Phillips-Perron test for Stationarity
def pp_test_fcn(data,maxlag):
    #@FORMAT: data = np(values)
    try:
        pp_fcn = UnitRoot.PhillipsPerron(data,maxlag)
        return pp_fcn.pvalue
    except:
        return np.nan




class PCAAnalysis():
    def __init__(self, data):
        # @FORMAT: data = df(X1, X2, X3, etc, index=dates)
        self.data = data
        self.X = self.data.values

    def getPCA(self,n_components):
        data = self.data
        X = data.values
        pca = PCA(n_components)
        pca.fit(X)
        newdata = pca.fit_transform(X)
        newdata = pd.DataFrame(newdata)
        self.pca_components = pca.components_

        self.pca_explained_var = pca.explained_variance_ratio_
        print(pca.explained_variance_ratio_)

        #covar_o = np.cov(np.transpose(X.values))
        #eigval_o, eigvec_o = np.linalg.eig(covar_o)
        #print(eigvec_o)
        #print(eigval_o)
        #covar = np.cov(np.transpose(newdata.values))
        #eigval, eigvec = np.linalg.eig(covar)
        #print(eigvec)
        #print(eigval)

    def getComponents(self):
        columns =  self.data.columns.values
        return pd.DataFrame(self.pca_components, columns=columns)

    def createLinearComponent(self):
        #Need to run getPCA() first
        a = self.X
        b = np.transpose(self.pca_components)
        c = np.dot(a,b)

        #Returns the linear component based on the loadings of each component generated by getPCA
        self.linearComponents = c
        print(c)
        return c

    #Creates a LM model and returns the prediction vector for the X_Pred
    def createLM(self,X,Y,X_Pred):
        lm = LM.LinearRegression(fit_intercept=True,copy_X=True)
        lm.fit(X,Y)
        Y_Pred = lm.predict(X_Pred)
        return Y_Pred


class RollingTraitStatFcns():
    #For the Signals_Testing.py getRollingTraitsgetRollingTraits fcn. Composed of statistic functions that take in an array and outputs a single statistic.
    # @FORMAT: data = np.array(price, column1, column2, etc)

    def __init__(self):
        pass

    # Calcs only correlations, get only the ith lags
    def acf_fcn_ith_cor(self,data, ith=2, lags=4, alpha=.05):
        #Takes only the first column, the price column
        price_data = data[:,0]

        try:
            acfvalues, confint, qstat, pvalues = acf(price_data, nlags=lags, qstat=True, alpha=alpha)
            result = acfvalues
            return result[ith]
        except:
            return np.nan

    # Calcs only p value of the acf, get only the ith lag
    def acf_fcn_ith_cor_pval(self,data, ith=2, lags=4, alpha=.05):
        #Takes only the first column, the price column
        price_data = data[:,0]
        try:
            acfvalues, confint, qstat, pvalues = acf(price_data, nlags=lags, qstat=True, alpha=alpha)
            result = pvalues
            return result[ith]
        except:
            return np.nan



    # Calcs p value for DF test, low p value means it's likely to have autocorrelations
    def dickeyfuller_fcn(self, data, maxlag=1):
        # Takes only the first column, the price column
        price_data = data[:, 0]
        df_fcn = adfuller(price_data, maxlag)
        return df_fcn[1]

    def hurstExp(self, data):
        price_data = data[:,0]
        return hurst_rs(price_data)